* Common LISP A Gentle Introduction - Touretzky, David S.

** Chapter 1

*** Data types

*Symbol* names may contain any combination of letters and numbers, plus special characters such as hypens.
*Integer* any sequence of digits with an optional plus or minus sign.
*T* and *NIL* are special symbols for true and false (emptiness).

*** Predicates

Functions suffixed with 'P' returning T or NIL that evaluate a predicate. i.e. ~ODDP~, ~EVENP~.

~EQUAL~ predicate compares two things to see if they are the same. There are others (~EQ~, ~EQL~, and ~EQUALP~), but ~EQUAL~ is ideal for initial learning.

~NOT~ negates a result.

** Chapter 2

*** Lists

- Are chains of cons cells.
- Cons cells are linked together by pointers.
- Last cons cell points to NIL.
- An empty list is represented by NIL.
  - NIL is still a valid input to ~LENGTH~ because NIL is also a list.

*** List operations

~FIRST~, ~SECOND~, ~THIRD~, ... return list item at that position.
~REST~ returns list containing everything but the first element.
~CAR~ (Contents of Address portion of Register) retrieves the CAR half of the cons cell.
~CDR~ (Contents of Decrement portion of Register) retrieves the CDR half of the cons cell.

*** Functions operate on pointers

Internally, everything is done by pointers, so a function's input / result isn't the object itself, but a pointer to the object.
For example, if you pass a list to a function, it receives a pointer to the first cons cell in the list.

In the case of ~CAR~, it receives a pointer to a cons cell and extracts the pointer sitting in the ~CAR~ half of the cell.
In the case of ~CDR~, it receives the pointer to a cons cell and extracts the pointer sitting in the ~CDR~ half of the cell.

~CONS~ (CONStruct) creates cons cells; it takes two inputs and returns a pointer to a new cons cell whose CAR points to the first input and whose CDR points to the second.

~LIST~ will make a cons cell chain list of its inputs.

*** Example: cons cells using pointers

If we ~CONS~ an item onto the head of list, the item simply points to the existing list.
Below illustrates that (parts of) the list are potentially shared amongst variables.

#+begin_src lisp :results output
  (setf a (list 'a 'b 'c))
  (setf b (cons 'd (cdr a)))
  (format t "a: ~a~%" a)
  (format t "b: ~a~%" b)
  (format t "change second element of list a to 'e~%")
  (setf (car (cdr a)) 'E)
  (format t "a: ~a~%" a)
  (format t "b: ~a~%" b)
#+end_src

#+RESULTS:
: a: (A B C)
: b: (D B C)
: change second element of list a to 'e
: a: (A E C)
: b: (D E C)

*** Other list forms

If the last cons cell of a list ends with a value instead of a NIL, it is a /dotted pair/; ~(A . B)~.

A list can be circular. Printing circular lists uses "sharp-equal notation"; ~#1=(A B C . #1#)~.

*** List Predicates

~LISTP~ returns T if its input is a list, or NIL.
~CONSP~ returns T if its input is a cons cell.
The difference between the two is NIL is a list, but /not/ a cons cell.

*** Escaping values in a list

To escape referencing a variable, use quotes.

#+begin_src lisp :results value
  (setf a (first '(fully escaped)))
  (setf b (first (list 'fully 'escaped)))
  (equal a b)
#+end_src

#+RESULTS:
: T

*** Internal structure of symbols

Symbols are actually composite objects that contain pointers that point to an internal representation, i.e. the symbol's name.

For symbols such as ~CONS~ and ~+~, they are used to name built-in lisp functions.
The symbol ~CONS~ has a pointer in its name cell pointing to "CONS", and a pointer in its function cell pointing to the compiled code object that performs the cons operation.

#+begin_src lisp :results value
  (list
    (symbol-name 'equal)
    (symbol-function 'equal))
#+end_src

#+RESULTS:
: ("EQUAL" #<FUNCTION EQUAL>)

*** Quoting functions

The first argument of ~apply~ is a function, escaping function calls is achieved via ~#'~

#+begin_src lisp :results value
  (apply #'+ '(2 3))
#+end_src

#+RESULTS:
: 5

** Chapter 4 - Conditionals

*** if

~if~ has three parts: test, true-part, false-part.
If true, returns value of true-part.
If false, returns value of false-part.

#+begin_src lisp :results value
  (defun symbol-test (x)
    (if (symbolp x) (list 'yes x 'is 'a 'symbol)
	(list 'no x 'is 'not 'a 'symbol)))
  (list
    (symbol-test 'rutabaga)
    (symbol-test 12345))
#+end_src

#+RESULTS:
| YES | RUTABAGA | IS | A   | SYMBOL |        |
| NO  |    12345 | IS | NOT | A      | SYMBOL |

If the false-part is missed, ~if~ will return ~nil~ on false.

#+begin_src lisp :results value
  (if nil 'happy)
#+end_src

#+RESULTS:
: NIL

*** cond

Goes through clauses sequentially until clause test is true.
If no clause test evaluates to true, ~cond~ returns nil.
t can be used as an else for the ~cond~.

#+begin_src lisp :results value
  (defun compare (x y)
    (cond ((equal x y) 'numbers-are-the-same)
	  ((< x y) 'first-is-smaller)
	  ((> x y) 'first-is-bigger)))

  (assert (equal (compare 3 5) 'first-is-smaller))
  (assert (equal (compare 7 2) 'first-is-bigger))
  (assert (equal (compare 4 4) 'numbers-are-the-same))
#+end_src

