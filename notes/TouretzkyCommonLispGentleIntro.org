* Common LISP A Gentle Introduction - Touretzky, David S.

** Chapter 1

*** Data types

*Symbol* names may contain any combination of letters and numbers, plus special characters such as hypens.
*Integer* any sequence of digits with an optional plus or minus sign.
*T* and *NIL* are special symbols for true and false (emptiness).

*** Predicates

Functions suffixed with 'P' returning T or NIL that evaluate a predicate. i.e. ~ODDP~, ~EVENP~.

~EQUAL~ predicate compares two things to see if they are the same. There are others (~EQ~, ~EQL~, and ~EQUALP~), but ~EQUAL~ is ideal for initial learning.

~NOT~ negates a result.

** Chapter 2

*** Lists

- Are chains of cons cells.
- Cons cells are linked together by pointers.
- Last cons cell points to NIL.
- An empty list is represented by NIL.
  - NIL is still a valid input to ~LENGTH~ because NIL is also a list.
- Lists are one-way chains of pointers. 

*** List operations

~FIRST~, ~SECOND~, ~THIRD~, ... return list item at that position.
~REST~ returns list containing everything but the first element.
~CAR~ (Contents of Address portion of Register) retrieves the CAR half of the cons cell.
~CDR~ (Contents of Decrement portion of Register) retrieves the CDR half of the cons cell.

*** Functions operate on pointers

Internally, everything is done by pointers, so a function's input / result isn't the object itself, but a pointer to the object.
For example, if you pass a list to a function, it receives a pointer to the first cons cell in the list.

In the case of ~CAR~, it receives a pointer to a cons cell and extracts the pointer sitting in the ~CAR~ half of the cell.
In the case of ~CDR~, it receives the pointer to a cons cell and extracts the pointer sitting in the ~CDR~ half of the cell.

~CONS~ (CONStruct) creates cons cells; it takes two inputs and returns a pointer to a new cons cell whose CAR points to the first input and whose CDR points to the second.

~LIST~ will make a cons cell chain list of its inputs.

*** Example: cons cells using pointers

If we ~CONS~ an item onto the head of list, the item simply points to the existing list.
Below illustrates that (parts of) the list are potentially shared amongst variables.

#+begin_src lisp :results output
  (setf a (list 'a 'b 'c))
  (setf b (cons 'd (cdr a)))
  (format t "a: ~a~%" a)
  (format t "b: ~a~%" b)
  (format t "change second element of list a to 'e~%")
  (setf (car (cdr a)) 'E)
  (format t "a: ~a~%" a)
  (format t "b: ~a~%" b)
#+end_src

#+RESULTS:
: a: (A B C)
: b: (D B C)
: change second element of list a to 'e
: a: (A E C)
: b: (D E C)

*** Other list forms

If the last cons cell of a list ends with a value instead of a NIL, it is a /dotted pair/; ~(A . B)~.

A list can be circular. Printing circular lists uses "sharp-equal notation"; ~#1=(A B C . #1#)~.

*** List Predicates

~LISTP~ returns T if its input is a list, or NIL.
~CONSP~ returns T if its input is a cons cell.
The difference between the two is NIL is a list, but /not/ a cons cell.

*** Escaping values in a list

To escape referencing a variable, use quotes.

#+begin_src lisp :results value
  (setf a (first '(fully escaped)))
  (setf b (first (list 'fully 'escaped)))
  (equal a b)
#+end_src

#+RESULTS:
: T

*** Internal structure of symbols

Symbols are actually composite objects that contain pointers that point to an internal representation, i.e. the symbol's name.

For symbols such as ~CONS~ and ~+~, they are used to name built-in lisp functions.
The symbol ~CONS~ has a pointer in its name cell pointing to "CONS", and a pointer in its function cell pointing to the compiled code object that performs the cons operation.

#+begin_src lisp :results value
  (list
    (symbol-name 'equal)
    (symbol-function 'equal))
#+end_src

#+RESULTS:
: ("EQUAL" #<FUNCTION EQUAL>)

*** Quoting functions

The first argument of ~apply~ is a function, escaping function calls is achieved via ~#'~

#+begin_src lisp :results value
  (apply #'+ '(2 3))
#+end_src

#+RESULTS:
: 5

** Chapter 4 - Conditionals

*** if

~if~ has three parts: test, true-part, false-part.
If true, returns value of true-part.
If false, returns value of false-part.

#+begin_src lisp :results value
  (defun symbol-test (x)
    (if (symbolp x) (list 'yes x 'is 'a 'symbol)
	(list 'no x 'is 'not 'a 'symbol)))
  (list
    (symbol-test 'rutabaga)
    (symbol-test 12345))
#+end_src

#+RESULTS:
| YES | RUTABAGA | IS | A   | SYMBOL |        |
| NO  |    12345 | IS | NOT | A      | SYMBOL |

If the false-part is missed, ~if~ will return ~nil~ on false.

#+begin_src lisp :results value
  (if nil 'happy)
#+end_src

#+RESULTS:
: NIL

*** cond

Goes through clauses sequentially until clause test is true.
If no clause test evaluates to true, ~cond~ returns nil.
t can be used as an else for the ~cond~.

#+begin_src lisp :results value
  (defun compare (x y)
    (cond ((equal x y) 'numbers-are-the-same)
	  ((< x y) 'first-is-smaller)
	  ((> x y) 'first-is-bigger)))

  (assert (equal (compare 3 5) 'first-is-smaller))
  (assert (equal (compare 7 2) 'first-is-bigger))
  (assert (equal (compare 4 4) 'numbers-are-the-same))
#+end_src

*** and / or macros

~and~ evalute the clauses one at a time.
- if a clause returns nil, stop and return nil.
- if all clauses yield non-nil results, return the value of the last clause.

#+begin_src lisp :results value
  (and 1 2 3)
#+end_src

#+RESULTS:
: 3

~or~ evaluate the clauses one at a time.
- if a clause returns a value other than nil, stop and return value.
- if a clause returns nil, continue to evaluate the next, if none are left, return nil.

#+begin_src lisp :results value
  (or nil 'value)
#+end_src

#+RESULTS:
: VALUE

*** evaluation of conditionals

The macros and / or don't evaluate their arguments unless they reach that input as part of their evaluation.
For example ~(or (oddp 3) (oddp 'asdf))~ won't error as ~(oddp 3)~ will evaluate to true.

If we were to create function ~(defun foo (a b) (and a b))~, and called via ~foo~ with the same parameters as above, it would error as the parameters would be evaluated when passed into the ~foo~ function.

*** step

~Step~ is built into lisps, for implementation specific commands, use "?".

~(step (if (oddp 5) 'yes 'no))~

** Chapter 5

Define a variable with ~defvar~.

#+begin_src lisp :results value
  (defvar trowels '(gardening pointing fishing)) ; value is optional
  (setf trowels (cons 'something trowels))
#+end_src

#+RESULTS:
| SOMETHING | GARDENING | POINTING | FISHING |

~setf~ used mostly for global variables; good practice to avoid changing value of local vars.

~let~ allows you to define scoped variables within the braces.

#+begin_src lisp :results value
  (defun switch-values (ls)
    (let ((head (first ls))
	  (last (third ls)))
      (list last head)))

  (switch-values '(mac and max))
#+end_src

#+RESULTS:
| MAX | MAC |

~let*~ creates local variables in sequence; a subsequent variable can depend on the result of an earlier one.

** Chapter 5

~append~ copies its first input and for the cdr of the last cell, attaches the second input.

#+begin_src lisp :results value
  (defvar a '(1 2 3))
  (defvar b '(4 5 6))
  (defvar c (append a b))
  (setf (car (cdr a)) 12) ; notice the result for c does not contain this
  (setf (car (cdr b)) 10)
  c
#+end_src

#+RESULTS:
| 1 | 2 | 3 | 4 | 10 | 6 |

~member~ checks whether an item is a member of a list.
If member is found, returns sublist beginning with that item, else nil.

~intersection~ returns the list of items existing in both sets.

~union~ returns the set of items that appear in either list, if appears in both, only included once.

~set-difference~ returns the set of items from the first input that were not in the second input.

*** Equality

Comparing lists via ~equal~ will compare lists element by element.
 
| ~eq~     | fastest equality, compares addresses. Compares symbols quickly and to determine if two cons cells are the same object. |
| ~eql~    | (default) will operate like ~eq~ except numbers (of the same type) are compared by value.                              |
| ~equal~  | compares lists element by element, otherwise works identical to ~eql~.                                                 |
| ~equalp~ | more liberal than ~equal~, ignores case in strings.                                                                    |
| ~=~      | most efficient for comparing numbers (even of different types).                                                        |

** Chapter 6

Association lists (tables) are lists of lists.

~assoc~ wwill search the car of each element.

#+begin_src lisp :results value
  (setf words
    '((one un)
      (two deux)
      (three trois)))
  (assoc 'three words)
#+end_src

#+RESULTS:
| THREE | TROIS |

~rassoc~ will search the cdr of each element. This requires the table to contain dotted pairs.

#+begin_src lisp :results value
  (setf words
    '((one . un)
      (two . deux)
      (three . trois)))
  (rassoc 'deux words)
#+end_src

#+RESULTS:
: (TWO . DEUX)

*** Tree Manipulation

~subst~ substitutes one item for another everywhere it appears in a list (including at different levels).

#+begin_src lisp :results value
  (subst 'the 'a
    '((a hatter) (a hare) (a dormouse)))
#+end_src

#+RESULTS:
| THE | HATTER   |
| THE | HARE     |
| THE | DORMOUSE |

~sublis~ operates similarly, but a list of subs can be provided via dotted pairs.

#+begin_src lisp :results value
  (defvar dotted-words
    '((one . un)
      (two . deux)
      (three . trois)))
  (sublis dotted-words
    '(three one two))
#+end_src

#+RESULTS:
| TROIS | UN | DEUX |

*** Efficiency of list operations

Comparing the two functions below

~(defun add-to-end-1 (x y) (append x (list y)))~ assuming list length n, it will create a total of n+1 new cons cells.
~append~ will copy the list x and attach it to the new ~(list y)~.

~(defun add-to-end-2 (x y) (reverse (cons y (reverse x))))~ creates a new list of reversed x (of length n), attaches y to the list (+ 1), then reverses the result, creating a new list of n+1 new cons cells.

The first function is clearly more efficient.

*** Keyword arguments

- Used for optional arguments.
- Always preceded by a colon.
- Symbol ~count~ and keyword symbol ~:count~ are not the same, they are different objects and not ~eq~ to each other.

For example ~member~ takes an optional argument ~:test~ that specifies how elements should be compared.

#+begin_src lisp :results value
  (defvar cards '((3 clubs) (5 diamonds) (ace spades)))
  (member '(5 diamonds) cards :test #'equal)
#+end_src

#+RESULTS:
|   5 | DIAMONDS |
| ACE | SPADES   |

** Chapter 7

- Applicative programming is based on the idea that functions are data; one should be able to pass functions as inputs to other functions, and also return functions as values.
- *Applicative operators* are functions that take another function as input and apply it to the elements of a list.

~funcall~ calls a function on some inputs.
#+begin_src lisp :results value
  (funcall #'cons 'a 'b)
#+end_src

#+RESULTS:
: (A . B)

~mapcar~ takes a function as input and applies it to each element in a list.

#+begin_src lisp :results value
  (defun square (x) (* x x))
  (mapcar #'square '(1 2 3 4 5))
#+end_src

#+RESULTS:
| 1 | 4 | 9 | 16 | 25 |

*** Lambda expressions

- Lambda is not a macro or special function that has to be evaluated, it is a marker that says "this list represents a function".
- Object you get back from a ~#'(lambda ...)~ expression can be referred to as *lexical closure*.
- A lambda expression can reference local variables inside lambda /and/ in the function containing the lambda expression.

#+begin_src lisp :results value
  (mapcar #'(lambda (x) (list 'hi 'there x))
	   '(joe fred wanda))
#+end_src

#+RESULTS:
| HI | THERE | JOE   |
| HI | THERE | FRED  |
| HI | THERE | WANDA |

*** Quotes

- ~'~ is shorthand for the ~quote~ special function.
- ~#'~ is shorthand for the ~function~ special function.

#+begin_src lisp :results value
  (reduce (function +) (quote (1 2 3)))
#+end_src

#+RESULTS:
: 6

If argument to ~function~ is a lambda expression, the result is usually a lexical closure.
To call a lexical closure, use ~funcall~ or ~apply~.

#+begin_src lisp :results value
  (setf g #'(lambda (x) (* x 10)))
  (funcall g 12) ; calling (g 12) would error as g is not the name of a function
#+end_src

#+RESULTS:
: 120

** Chapter 8: Recursion

Three rules of recursion
1) Know when to stop
2) Decide how to take one step
3) Break the journey down into that step plus a smaller journey

~labels~ can be used as an alternative to one function calling another when they are tightly coupled.

#+begin_src lisp :results value
  (defun count-up (n)
    (labels ((count-up-recursively (cnt)
      (if (> cnt n) nil
	  (cons cnt
		(count-up-recursively (+ cnt 1))))))
    (count-up-recursively 1)))

  (count-up 5)
#+end_src

#+RESULTS:
| 1 | 2 | 3 | 4 | 5 |

*** Recursive Data Structures

An /S-expression/ is either an atom, or a cons cell whose CAR and CDR parts are S-expressions.
A tree is either a single terminal node, or a nonterminal node whose branches are trees.

/Terminal nodes/ are the bottom nodes as they have no branches descending from them.
/Nonterminal Nodes/ are the rest of the nodes as they have branches.

** Chapter 9: IO

~format~ returns nil, but as a side effect it prints to screen or writes to a file.
- First argument is ~t~ if we want to print to screen.
- Second argument is format control string.
  - Special formatting directives begin with ~~~
  - Considered good practice to prefix control string with ~~&~

| Symbol | Description                                  |
|--------+----------------------------------------------|
| ~%     | New line                                     |
| ~&     | New line if not already at new line          |
| ~S     | S-expression                                 |
| ~10S   | As above but with a width of 10              |
| ~A     | Print object without using escape characters |

*** Reading files ***

The below demonstrates how to persist data in a way that common lisp can directly read it back in as S-expressions.

~with-open-file~ provides a means to read data

#+begin_src
  "Test Data"
  ((45 redwood) (12 oak) (43 maple))
  100
#+end_src

#+begin_src lisp :results output
  (defun get-tree-data ()
    (with-open-file (stream "./test_data.dat")
      (let* ((tree-loc (read stream))
	      (tree-table (read stream))
	      (num-trees (read stream)))
	(format t "~&There are ~S trees on ~S."
		num-trees tree-loc)
	(format t "~&They are: ~S" tree-table))))

  (get-tree-data)
#+end_src

#+RESULTS:
: There are 110 trees on "The West Ridge".
: They are: ((45 REDWOOD) (22 OAK) (43 MAPLE))

A solution to reading a file with a non-predetermined length is to have an EOF indicator.
Potentially an empty single cons cell could be used, but another option is ~(list '$eof$)~.

*** Writing files ***

~with-open-file~ provides a means to write data

#+begin_src lisp :results value
  (defun save-tree-data (tree-loc tree-table num-trees)
    (with-open-file (stream "./test_data.dat"
		       :direction :output :if-exists :overwrite)
      (format stream "~S~%" tree-loc)
      (format stream "~S~%" tree-table)
      (format stream "~S~%" num-trees)))

  (save-tree-data
    "The West Ridge"
    '((45 redwood) (22 oak) (43 maple))
    110)
#+end_src

#+RESULTS:
: NIL

This can be tested with the code in the read files section.

** Advanced: Symbols

- There can only be one symbol in the computer's memory with a given name.
- Every object in memory has a numbered location (address).
- Since a symbol exists in only one place in memory, symbols have unique addresses.

Internally a symbol is composed of five components.

- Name
- Function cell
- Value cell

If global variable TOTAL has the value 12, internal structure would appear as:
| Name  | "TOTAL" |
| Value |      12 |

If global variable FISH has the value TROUT, the structure would appear as:
| Name  | "FISH"             |
| Value | <Pointer to TROUT> |

| Name | "TROUT" |


** Advanced: Using Trace

- ~trace~ allows you to watch particular functions when they are called.
- ~untrace~ turns off the tracing
- the above two can be mixed; i.e. in the below scenario you could ~untrace~ average once you have confirmed it works fine, and half would still trace.

#+begin_src lisp :results value
  (defun half (n) (* n 0.5))
  (defun average (x y) (+ (half x) (half y)))
  (trace half average)
  ; can now call the below and see trace information
  (average 3 7)
#+end_src

#+RESULTS:
: 5.0

** Advanced: Dribble

Using the ~dribble~ function with a filename will start recording a session in your repl.
Calling ~dribble~ again will complete the recording.
